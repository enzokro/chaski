# AUTOGENERATED! DO NOT EDIT! File to edit: ../content/02_complexRayleighInitPost.ipynb.

# %% auto 0
__all__ = ['sigma', 'points', 'ray_pdf', 'fig', 'ax', 'seed', 'rand', 'shape', 'ray_vals', 'large_shape', 'many_ray_vals',
           'phase', 'real', 'imag', 'chosen_samples', 'fan_in', 'fan_out', 'sigma_he', 'm', 'magnitude', 'k',
           'conv_layer', 'real_conv', 'imag_conv', 'conv_magnitude', 'sigma_he_conv', 'rayleigh_pdf',
           'get_complex_inits']

# %% ../content/02_complexRayleighInitPost.ipynb 7
import matplotlib.pyplot as plt
import numpy as np
import torch
from numpy.random import RandomState

# %% ../content/02_complexRayleighInitPost.ipynb 12
def rayleigh_pdf(x, sigma):
    "Evaluates the Rayleigh PDF at a given point `x`."
    p = (x / sigma**2) * np.exp(-x**2 / (2*sigma**2)) # see if you can match this code to the equation above
    return p

# %% ../content/02_complexRayleighInitPost.ipynb 15
# start with sigma of one as the base case
sigma = 1

# calculate the Rayleigh PDF on 100 equally spaced points between 0 and 5
points = np.linspace(0, 5, 100)
ray_pdf = rayleigh_pdf(points, sigma)

# %% ../content/02_complexRayleighInitPost.ipynb 16
# plot the Rayleigh pdf
fig, ax = plt.subplots(figsize=(8,7))
ax.plot(ray_pdf)
ax.set_xticklabels([-1] + list(range(len(ax.get_xticklabels()))))
ax.set_xlabel('Sample Value', fontsize='x-large')
ax.set_ylabel('Probability Density', fontsize='x-large')
ax.set_title('Rayleigh PDF', fontsize='xx-large');

# %% ../content/02_complexRayleighInitPost.ipynb 24
seed = 0
rand = RandomState(seed)

# %% ../content/02_complexRayleighInitPost.ipynb 27
sigma = 1
shape = 1000
# one dimensional vector with 1000 samples
ray_vals = rand.rayleigh(scale=sigma, size=shape)

# %% ../content/02_complexRayleighInitPost.ipynb 29
# plot histogram of 1000 drawn samples
plt.figure(figsize=(8,7))
plt.hist(ray_vals, bins=50)
plt.xlabel('Sample Value', fontsize='x-large')
plt.ylabel('Counts', fontsize='x-large')
plt.title(f'Histogram of {shape:,} Rayleigh samples', fontsize='xx-large');

# %% ../content/02_complexRayleighInitPost.ipynb 31
large_shape = 10000
many_ray_vals = rand.rayleigh(scale=sigma, size=large_shape)
plt.figure(figsize=(8,7))
plt.hist(many_ray_vals, bins=35);
plt.xlabel('Sample Value', fontsize='x-large')
plt.ylabel('Counts', fontsize='x-large')
plt.title(f'Histogram of {large_shape:,} Rayleigh samples', fontsize='xx-large');

# %% ../content/02_complexRayleighInitPost.ipynb 33
# setup the plot again
plt.figure(figsize=(8,7))
plt.title('Sampled vs. Theoretical Rayleigh PDFs', fontsize='x-large')
plt.xlabel('Sample Value', fontsize='x-large')
plt.ylabel('Probability Density', fontsize='x-large')


# compare theoretical vs. sampled Rayleigh PDFs
plt.hist(many_ray_vals, density=True, bins=35) # makes the histogram sum to one, to mimic pdf
plt.plot(points, ray_pdf, c='r', label='theoretical rayleigh pdf', linewidth=3)
plt.legend();

# %% ../content/02_complexRayleighInitPost.ipynb 37
# pick random directions along the unit circle
phase = rand.uniform(low=-np.pi, high=np.pi, size=ray_vals.shape)

# %% ../content/02_complexRayleighInitPost.ipynb 39
real = ray_vals * np.cos(phase)
imag = ray_vals * np.sin(phase)

# %% ../content/02_complexRayleighInitPost.ipynb 41
# indexes for the first 500 random weights
chosen_samples = range(500) 

# plot these first complex weights
plt.figure(figsize=(8,7))
for idx in chosen_samples:

    # index into phase and magnitude variables
    angle,mag = phase[idx],ray_vals[idx]

    # plot them starting from the origin
    plt.polar([0,angle], [0,mag], marker='o')

# %% ../content/02_complexRayleighInitPost.ipynb 61
def get_complex_inits(module, seed=None, criterion='he', dtype='float32'):
    """Initializes complex-valued Rayleigh weights as PyTorch tensors.
    """
    # random number generator
    rand = RandomState(seed if seed is None else torch.initial_seed())
    
    # get shape of the weights
    weight_shape = module.weight.size()
    
    # find the number of input and output connection
    fan_in, fan_out = torch.nn.init._calculate_fan_in_and_fan_out(module.weight)
    
    # compute the Rayleigh sigma that meets the chosen variance criteria
    assert criterion in ('he','glorot')
    factor = fan_in if criterion == 'he' else fan_in + fan_out
    sigma = 1. / np.sqrt(factor)
    
    # draw the scaled rayleigh magnitudes
    magnitude = rand.rayleigh(scale=sigma, size=weight_shape)
    # draw uniform angle samples
    phase = rand.uniform(low=-np.pi, high=np.pi, size=magnitude.shape)
    
    # split magnitudes into real and imaginary components
    real = (magnitude * np.cos(phase)).astype(dtype)
    imag = (magnitude * np.sin(phase)).astype(dtype)
    
    # turn into float tensors and return
    real,imag = map(torch.from_numpy, [real,imag])
    return real,imag
    

# %% ../content/02_complexRayleighInitPost.ipynb 63
# re-create out earlier example with a single layer
fan_in, fan_out = 100, 50
sigma_he = 1. / np.sqrt(fan_in)

# get the complex-valued weights
m = torch.nn.Linear(fan_in, fan_out)
real, imag = get_complex_inits(m)

# %% ../content/02_complexRayleighInitPost.ipynb 65
# grab magnitude as flat vector of numpy samples
magnitude = torch.sqrt(real**2 + imag**2).numpy().reshape(-1)

# %% ../content/02_complexRayleighInitPost.ipynb 66
# plot histogram of magnitudes vs. theoretical pdf
plt.figure(figsize=(8,7))
plt.title('Complex nn.Linear Weights vs. Theoretical Rayleigh PDF', fontsize='x-large')
plt.xlabel('Sample Value', fontsize='x-large')
plt.ylabel('Probability Density', fontsize='x-large')

# pick points that cover the sample range to compare with theoretical rayleigh pdf
points = np.linspace(0, magnitude.max(), 1000)
ray_pdf = rayleigh_pdf(points, sigma=sigma_he)

plt.hist(magnitude, bins=35, density=True)
plt.plot(points, ray_pdf, c='r', linewidth=3);

# %% ../content/02_complexRayleighInitPost.ipynb 70
# make conv layer with 100 input features, 50 output features, and (3x3) kernel

# set a 3x3 kernel size
k = 3 
conv_layer = torch.nn.Conv2d(fan_in, fan_out, k)
real_conv, imag_conv = get_complex_inits(conv_layer) # get the initial complex weights

# make sure the shape of weights is ok
print(f'Shapes of real and imaginary convolution tensors: {real_conv.shape}, {imag_conv.shape}')

# %% ../content/02_complexRayleighInitPost.ipynb 72
# grab magnitude as flat vector of numpy samples
conv_magnitude = torch.sqrt(real_conv**2 + imag_conv**2).numpy().reshape(-1)

# %% ../content/02_complexRayleighInitPost.ipynb 73
# plot histogram of magnitudes vs. theoretical pdf
plt.figure(figsize=(8,7))
plt.title('Complex nn.Conv2d Weights vs. Theoretical Rayleigh PDF', fontsize='x-large')
plt.xlabel('Sample Value', fontsize='x-large')
plt.ylabel('Probability Density', fontsize='x-large')


# pick points that cover sample range to compare with theoretical rayleigh pdf
points = np.linspace(0, conv_magnitude.max(), 1000)

# note: we need to re-compute fanIn for the convolutional layer
fan_in, fan_out = torch.nn.init._calculate_fan_in_and_fan_out(conv_layer.weight)
sigma_he_conv = sigma=1. / np.sqrt(fan_in)

ray_pdf = rayleigh_pdf(points, sigma_he_conv)

# plot the two distributions
plt.hist(conv_magnitude, bins=35, density=True)
plt.plot(points, ray_pdf, c='r', linewidth=3);
